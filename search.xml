<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[字符串转化]]></title>
    <url>%2F2019%2F09%2F25%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%2F</url>
    <content type="text"><![CDATA[字符串转化leetcode 第6场双周赛题目给出两个长度相同的字符串，分别是 str1 和 str2。请你帮忙判断字符串 str1 能不能在 零次 或 多次 转化后变成字符串 str2。 每一次转化时，将会一次性将 str1 中出现的 所有 相同字母变成其他 任何 小写英文字母（见示例）。 只有在字符串 str1 能够通过上述方式顺利转化为字符串 str2 时才能返回 True，否则返回 False。​​ 示例 1： 输入：str1 = &quot;aabcc&quot;, str2 = &quot;ccdee&quot; 输出：true 解释：将 &apos;c&apos; 变成 &apos;e&apos;，然后把 &apos;b&apos; 变成 &apos;d&apos;，接着再把 &apos;a&apos; 变成 &apos;c&apos;。注意，转化的顺序也很重要。示例 2： 输入：str1 = &quot;leetcode&quot;, str2 = &quot;codeleet&quot; 输出：false 解释：我们没有办法能够把 str1 转化为 str2。 提示： 1 &lt;= str1.length == str2.length &lt;= 10^4 str1 和 str2 中都只会出现 小写英文字母解题思路 主要思路是建立一个HashMap,将当前字符串中的信息存进map,该HashMap 的 key 为字符 即(a ~ z),value为 该字符串中,该字符所在位置的下标集合,为HashSet&lt;Integer&gt;类型 例: str1 = &quot;aabcc&quot;, str2 = &quot;ccdee&quot;此时map1内的内容为: key value a 0、1 b 2 c 3、4 map2内的内容为: key value c 0、1 d 2 e 3、4 此时，遍历map2中的value,即set1,第一组中的为0、1，首先是0，根据此下标找到str1对应位置的字符，即str1.charAt(0);，此时的字符为a,在通过a(key），找到map1中字符a的下标集合set2，然后判断这个集合是否为set1中的子集。若不是，则不能完成转换经遍历后，均满足，遂返回true 意思就是说，str2中的某一类字符，必须由str1中对应位置的一类或者几类字符转化而来，且str1中的这些字符不能用作转化为其他字符。 例如：str1=&quot;abcde&quot; str2=&quot;eeexy&quot; 则输出true; 当str2中的字符种类为26时，除非str1等于str2,否则无法完成转化， 例如：str1=&quot;bcdefghijklmnopqrstuvwxyza&quot;; str2=&quot;abcdefghijklmnopqrstuvwxyz&quot;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Solution &#123; public boolean canConvert(String str1, String str2) &#123; //如果为空或者长度不相等,直接返回false if (str1.isEmpty()|| str2.isEmpty() || str1.length() != str2.length()) return false; //若两个字符串相等则直接返回true if (str1.equals(str2)) return true; //根据两个字符串初始化出两个map HashMap&lt;Character,HashSet&lt;Integer&gt;&gt; map1 = initialize(str1); HashMap&lt;Character,HashSet&lt;Integer&gt;&gt; map2 = initialize(str2); //分别获取两个map的size ,即两个字符串的字符种类数量 int num1 = map1.size(); int num2 = map2.size(); //如果str1的字符种类数量少于str2,或者str2的字符种类数量为26, //则不可能进行转换,因为无法存在转换的中间值,必然会导致失败 if (num1 &lt; num2 || num2 == 26) return false; //遍历map2中的数值(value) for (HashSet&lt;Integer&gt; value : map2.values()) &#123; //遍历当前set中的值 for (Integer n : value) &#123; //找到str2中对应str1相同位置的字符c Character c = str1.charAt(n); //从map1中获取字符c所对应的下标集合set HashSet&lt;Integer&gt; set = map1.get(c); //判断set中的数值是否完全属于value //若不是,则返回false if (!isOnly(value,set)) &#123; return false; &#125; &#125; &#125; return true; &#125; /** * 将当前字符串中的信息存进map * 该HashMap 的 key 为字符 即(a~z), * value为 该字符串中,该字符所在位置的下标集合,为HashSet&lt;Integer&gt;类型 * @param str * @return */ public HashMap&lt;Character,HashSet&lt;Integer&gt;&gt; initialize(String str) &#123; HashMap&lt;Character,HashSet&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; str.length(); i++) &#123; Character c = str.charAt(i); if (map.containsKey(str.charAt(i))) &#123; HashSet&lt;Integer&gt; set = map.get(c); set.add(i); map.put(c, set); &#125; else &#123; HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); set.add(i); map.put(c, set); &#125; &#125; return map; &#125; /** * 判断set1中的数值是否完全属于set2 * 即判断 set1 是否为 set2 的子集 * 若不是,则返回false * @param set2 * @param set1 * @return */ public boolean isOnly(HashSet&lt;Integer&gt; set2,HashSet&lt;Integer&gt; set1)&#123; boolean is = true; for (Integer n : set1) &#123; if (!set2.contains(n))&#123; is = false; &#125; &#125; return is; &#125;&#125;]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[等价多米诺骨牌对的数量]]></title>
    <url>%2F2019%2F09%2F25%2F%E7%AD%89%E4%BB%B7%E5%A4%9A%E7%B1%B3%E8%AF%BA%E9%AA%A8%E7%89%8C%E5%AF%B9%E7%9A%84%E6%95%B0%E9%87%8F%2F</url>
    <content type="text"><![CDATA[等价多米诺骨牌对的数量LeetCode 第 146场周赛题目给你一个由一些多米诺骨牌组成的列表 dominoes。 如果其中某一张多米诺骨牌可以通过旋转 0 度或 180 度得到另一张多米诺骨牌，我们就认为这两张牌是等价的。 形式上，dominoes[i] = [a, b] 和 dominoes[j] = [c, d] 等价的前提是 a==c 且 b==d，或是 a==d 且 b==c。 在 0 &lt;= i &lt; j &lt; dominoes.length 的前提下，找出满足 dominoes[i] 和 dominoes[j] 等价的骨牌对 (i, j) 的数量。 示例： 输入：dominoes = [[1,2],[2,1],[3,4],[5,6]] 输出：1提示： 1 &lt;= dominoes.length &lt;= 40000 1 &lt;= dominoes[i][j] &lt;= 9 解题思路 本题对算法复杂度的要求较高，使用暴力的方式用时太大 利用HashMap的特性来优化算法的复杂度 改变数字对内两个数字的顺序不会影响最终结果,所以将所有多米诺骨牌 数值均改成 从小到大的顺序 一级map的key1为数字对第一位的值,value1为二级map 二级map的key2为数字对第二位的值,value2为该数字对的出现次数 例如[[1,2],[2,1],[3,4],[5,6]] 存储进Map之后的值为 key1 key2 value2 1 2 2 3 4 1 5 6 1 当往map中插入数值时,若已存在(即value2的值为 &gt;=1 的数值)便将总数sum加上value2的值,再将value2的值+1 若不存在,则创建,并将value2的值初始化为1 代码（Java)123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; public int numEquivDominoPairs(int[][] dominoes) &#123; //初始化Map集合 HashMap&lt;Integer, HashMap&lt;Integer, Integer&gt;&gt; map = new HashMap&lt;&gt;(); //定义总数sum，并初始化为0 int sum = 0; //循环遍历二维数组dominoes for (int i = 0; i &lt; dominoes.length ; i++) &#123; //获取当前「数字对」的值，并将较小的值设置为a,较大的值设置为b Integer a = dominoes[i][0]; Integer b = dominoes[i][1]; if (a &gt; b) &#123; a = dominoes[i][1]; b = dominoes[i][0]; &#125; //将a 作为Map1的key1 //而b 作为Map1的value1 （即map2) 的key2 //判断Map1中是否有key1 为 a 的值 if (map.containsKey(a)) &#123; HashMap&lt;Integer, Integer&gt; list = map.get(a); //判断Map2中是否有key2 为 b 的值 if (list.containsKey(b)) &#123; //获取value2的值并加入到sum中 int count = list.get(b); sum = sum + count; //对应的value的值+1 list.put(b, count+1); map.put(a, list); &#125; else &#123; //初始化数值为1 list.put(b, 1); map.put(a, list); &#125; &#125; else &#123; //初始化数值为1 HashMap&lt;Integer, Integer&gt; list = new HashMap&lt;&gt;(); list.put(b, 1); map.put(a, list); &#125; &#125; return sum; &#125;&#125;]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>java</tag>
      </tags>
  </entry>
</search>
